

연결리스트에서 `head`를 다룰 때 이중포인터를 사용하는 데에는 두 가지 주요 이유가 있습니다.

## 1. 함수 내에서 head의 값을 변경하기 위해서

- C언어에서 함수에 포인터를 전달하면 포인터의 값이 복사되어 전달됩니다. 따라서 함수 내에서 포인터의 값을 변경해도 원본 포인터에는 영향을 주지 않습니다.
- 연결리스트의 `head`는 리스트의 시작점을 가리키는 포인터입니다. 노드를 삽입하거나 삭제할 때 `head`의 값이 변경될 수 있습니다.
- 이중포인터를 사용하면 함수 내에서 `head`의 값을 변경할 수 있고, 그 변경사항이 원본 `head`에도 반영됩니다.

## 2. 연결리스트가 비어있는 경우를 처리하기 위해서

- 연결리스트가 비어있다면 `head`는 `NULL`을 가리킵니다.
- 새로운 노드를 삽입할 때, `head`가 `NULL`인 경우 `head` 자체를 새로운 노드를 가리키도록 변경해야 합니다.
- 이중포인터를 사용하면 `head`가 `NULL`인 경우에도 `head`의 값을 직접 변경할 수 있습니다.

## 예시

새로운 노드를 연결리스트의 맨 앞에 삽입하는 함수를 살펴봅시다.

```c
void insertNode(Node** head, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = *head;
    *head = newNode;
}
```

위 함수에서 `head`는 이중포인터입니다. 함수 내에서 `*head`를 통해 원본 `head`의 값에 접근하고, `*head = newNode`를 통해 `head`의 값을 직접 변경합니다.

이렇게 이중포인터를 사용하면 함수 내에서 `head`의 값을 변경하고, 그 변경사항을 원본 `head`에 반영할 수 있습니다. 또한 연결리스트가 비어있는 경우에도 `head`의 값을 적절히 변경할 수 있게 됩니다.

## 단일포인터로 head를 다루면 안 되는 이유

단일포인터로 `head`를 다루면 함수 내에서 `head` 포인터의 값을 변경해도 함수 호출 이후에는 그 변경사항이 유지되지 않습니다. 함수에 포인터를 전달하면 포인터의 값이 복사되어 전달되기 때문입니다.

따라서 연결리스트에서 `head`를 다룰 때는 이중포인터를 사용하여 함수 내에서 `head`의 값을 변경하고, 그 변경사항을 원본 `head`에 반영할 수 있도록 해야 합니다.